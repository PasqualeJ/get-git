{"name":"get-git","tagline":"Un manuale per imparare git rapidamente e senza grattacapi","body":"# Introduzione\r\n\r\nQuesta guida è un po' differente.\r\nTutte le guide che ho letto su git si preoccupano di introdurti ai comandi base di git e lasciano ai capitoli più avanzati la descrizione degli internal e del modello di funzionamento.\r\nQuello che ho notato, però, è che imparando git così, molti finiscono per valutarlo uno strumento simile a SVN provvisto di un set aggiuntivo di comandi complicati, il cui funzionamento resta sostanzialmente oscuro.\r\nFacci caso: chiedi ai colleghi che già conoscono git se abbiano mai capito cosa sia l'index e se saprebbero spiegarti la differenza tra merge e rebase. Alcuni ti risponderanno di aver imparato git abbasanza da riuscire ad usarlo quotidianamente, ma di aver fatto molta fatica a capire cosa sia un rebase, o di non cogliere esattamente che uso fare dello stage. \r\nLa mia impressione è che, una volta capito il modello interno (che è stupefacentemente semplice!) tutto git diventi improvvisamente lineare e coerente: non c'è davvero alcun motivo per cui il \"rebase\" dovrebbe essere un argomento misterioso.\r\n\r\nQuesta guida prova a spiegare git seguendo un percorso contrario a quello adottato di solito: partirai da una breve spiegazione degli internal, e finirai per imparare i comandi base e quelli avanzati (insieme!) in poco tempo e senza alcun grattacapo.\r\n\r\n\r\n# Non sono parente di SVN\r\n\r\nPer chi arriva da SVN, git presenta una sola difficoltà: gli assomiglia vagamente. Ma è una somiglianza superficiale e ingannevole: sotto il cofano è totalmente differente.\r\n\r\nPer questo ti suggerisco di rifuggire sempre dalla tentazione di fare dei paralleli: sarebbero solo fuorvianti. Troverai comandi come add, checkout, commit, branch che ti sembrerà di conoscere. Ecco: fai tabula rasa di quel che conosci, perché in git quei comandi significano cose molto molto differenti.\r\n\r\n# Setup \r\n\r\nInstalla git.\r\nPoi configuralo perché ti riconosca\r\n\r\n  git config --global user.name \"Arialdo Martini\"\r\n  git config --global user.emal arialdomartini@gmail.com\r\n\r\nSe vuoi, installa anche un client grafico. Io ti suggerisco SmartGit, che è gratuito per progetti OpenSource.\r\nSei pronto per usare git.\r\n\r\n# Il modello\r\n## 3 differenze principali\r\n\r\n1. Non c'è un server: il repository è locale; git lavora al livello di nerdosità 4. La gran parte delle operazioni è locale e non richiede l'accesso alla rete. Anche per questo git è veloce a bestia.\r\n2. Snapshot: git lavora sempre con l'intero codice sorgente del progetto e non singole directory o singoli file; con git non c'è differenza tra committare nella root o in una subdirectory. Non esiste il concetto di committare o fare il checkout di un file o di una directory: git lavora sempre sull'intero snapshot del progetto.\r\n3. Blob, non diff: non memorizza diff ma l'intero file. Se in un file di 2 mega cambiassi un singolo carattere, git memorizzerebbe per intero la nuova versione del file. Questa è una differenza importante: SVN memorizza le differenze e, all'occorrenza, ricostruisce il file; git memorizza il file e, all'occorrenza, ricostruisce le differenze.\r\n\r\n\r\n### Livelli di nerdosità\r\n\r\nSull'assenza di un server ho un po' mentito: come vedrai più avanti, git è un sistema peer-to-peer, e riesce ad interagire con dei server remoti.\r\nMa resta, sostanzialmente, un sistema locale.\r\n\r\nPer capire quanto questo possa avvantaggiarti, pensa a questo: quando il codice sorgente di un progetto è ospitato su un computer remoto hai 4 modi per editare il codice\r\n\r\n1. lasci tutto il codice sul computer remoto e vi accedi con ssh per editare i file\r\n2. trovi il modo di ottenere una copia locale del (singolo) file e lasci tutto il resto sul computer remoto\r\n3. ottieni una copia locale di un intero albero del filesystem  e lasci il resto della storia dei commit sul computer remoto\r\n4. ottenieni una copia locale dell'intero repository con tutti i suoi commit e lavori tutto in locale\r\n\r\nAvrai notato due cose.\r\nLa prima, che SVN e i sistemi di versionamento ai quali sei probabilmente abituato operano al livello 3.\r\nLa seconda, che i 4 sistemi sono elencati in ordine di comodità: quando il materiale è conservato sul sistema remoto, normalmente, il tuo lavoro è più macchinoso e scomodo.\r\ngit preferisce farti avere tutto a disposizione, sul tuo computer locale.\r\nQualunque cosa tu faccia, git chiede normalmente di ottenere una copia completa di quel che è presente sul server remoto. Ma non preoccuparti: git è più veloce a ottenere l'intera storia del progetto di quanto SVN lo sia ad ottenere un singolo checkout.\r\n\r\n\r\n### Modello di storage\r\n\r\nPassiamo dalla terza differenza. \r\nSVN memorizza i file e la collezione delle varie patch (o diff) applicate nel tempo. \r\ngit invece memorizza i file così come sono, nella loro interezza.\r\n\r\nSe vuoi evitare tanti grattacapi con git, il miglior suggerimento che tu possa seguire è di trattarlo come un database chiave-valore. \r\n\r\nMettiamo di avere 2 file sul filesystem \r\n\r\n\r\n    /\r\n    ├──libs\r\n    |     └──foo.txt\r\n    |\r\n    ├──templates\r\n            └──bar.txt\r\n\r\n\r\ne di volerli aggiungere a git.\r\n\r\n  git init\r\n  git add libs/foo.txt\r\n  git add templates/bar.txt\r\n\r\n\r\nCon questi comandi, git prende il contenuto dei 2 file e li memorizza nel suo database chiave-valore, che è conservato su filesystem (nella directory nascosta .git) . Il database si chiama \"blob storage\"; git guarda il contenuto di ogni file git e gli associa un identificativo unico, la chiave (banalmente: è lo sha1 del file). Il  valore sarà il contenuto del file.\r\n\r\n    git add libs/foo.txt       ===> git salva nel Blob storage qualcosa come { chiave: ae6757ff, valore: contenuto di foo.txt}\r\n    git add templates/bar.txt  ===> git salva nel Blob storage { chiave: bbe51002, valore: contenuto di bar.txt}\r\n\r\nOra, come vedi, il Blob storage conserva solo il contenuto dei file, non il loro nome. Per cui, se libs/foo.txt e templates/bar.txt avessero lo stesso contenuto, nel blob storage entrambi verrebbero conservati in un unico oggetto, identificato dal suo sha1: ae6757ff\r\n\r\n    git add libs/foo.txt              ===> Blob storage { chiave: ae6757ff, valore: contenuto_comune}\r\n    git add templates/bar.txt         ===> Blob storage { chiave: ae6757ff, valore: contenuto_comune} \r\n\r\n\r\nNaturalmente, però, a noi il nome dei file e la loro posizione interessano eccome.\r\nPer questo, nel blob storage, git memorizza anche vari altri oggetti, chiamati \"tree\" che servono proprio a memorizzare il contenuto delle varie directory e i nomi dei file.\r\n\r\nNel nostro caso, avremo 3 tree \r\n\r\n   /\r\n   libs\r\n   template\r\n\r\ngit memorizzerà che \"libs\" contiene \"foo.txt\", \"template\" contiene \"bar.txt\" e \"/\" contiene le directory \"libs\" e \"templates\".\r\nCome ogni altro oggetto, anche i tree sono memorizzati come chiave/valore.\r\n\r\n   /         => contiene libs e template\r\n   libs      => contiene foo.txt\r\n   template  => contiene bar.txt\r\n\r\n\r\nEssendo un database chiave-valore, per fare riferimento ad un elemento, git userà sempre la sua chiave.\r\n\r\nTutte queste strutture vengono raccolte dentro un contenitore, chiamato \"commit\".\r\n\r\nCome forse avrai intuito, un \"commit\" è un altro oggetto chiave-valore, la cui chiave è uno SHA1, come per tutti gli altri oggetti, e il cui valore è la collezione dei puntatori ai tree contenuti, cioè l'elenco delle loro chiavi.\r\nNon è troppo complicato, dopo tutto, no?\r\n\r\nQuindi, il commit è l'attuale fotografia dello stato del filesystem.\r\n\r\nQuando facciamo\r\n\r\n       git commit -m \"il mio primo commit\"\r\n\r\nstiamo dicendo a git: \"memorizza nel repository, cioè nella storia del progetto, il commit che ti ho preparato a colpi di add\"\r\n\r\n\r\n### Index o stage\r\n\r\nFino ad ora ti ho parlato degli internal di git. Tra pochissimo arriviamo ai comandi. Ma prima vediamo un altro meccanismo interno: l'\"index\" o lo \"stage\". Lo stage risulta sempre misterioso a chi arrivi da SVN: vale la pena parlarne perché quando si sa come funziona il blob storage e lo stage, git passa da sembrare un tool contorto e incomprensibile ad essere un oggetto molto lineare e coerente.\r\n\r\n\r\n\r\nLo stage è una struttura che fa da cuscinetto tra il filesystem e il repository.\r\n\r\n\r\n    filesystem   |   stage   |   repository\r\n\r\n\r\nIl file system è la directory con i nostri file.\r\nIl repository è un database su file, locale, che conserva la storia del filesystem\r\nLo stage è lo spazio che git mette a disposizione per creare il prossimo commit.\r\n\r\nFisicamente, lo stage assomiglia molto al repository: entrambi conservano i dati nel blob storage, usando le strutture che hai visto prima.\r\n\r\n\r\n    filesystem   |   stage   |   repository\r\n                        \\          |\r\n                         \\__ Blob storage\r\n\r\n\r\n\r\nProviamo a fare delle modifiche ai nostri due file (magari aggiungendone un terzo) e committarle.\r\n\r\nAvevamo\r\n\r\n\r\n    /\r\n    ├──libs\r\n    |     └──foo.txt\r\n    |\r\n    ├──templates\r\n            └──bar.txt\r\n\r\n\r\ne nel blob storage avevamo\r\n\r\n     [ commit 1 ]\r\n       |    |\r\n       |     \\\r\n       |      └── tree object  \"libs\" \r\n       |          contains \"foo.txt\"\r\n       |                        |\r\n       |                        └────────────────────────────────────────\r\n       |                                                                 \\\r\n       └──── tree oject (name=templates)                                  \\\r\n                        (contains: bar.txt)                                \\       \r\n                                  |                                         \\ \r\n                                  └────────────────────────────────────── blob object (contenuto del file)\r\n\r\n   \r\n\r\n\r\n\r\nA bocce ferme, lo stage contiene la situazione dalla quale partiamo, quindi il primo commit che avevamo fatto, con tutti i suoi tree object e i suoi blob.\r\nLo stage sta lì, in attesa di accogliere le modifiche che abbiamo fatto sul filesystem.\r\n\r\nModifichiamo \"foo.txt\", e aggiorniamo lo stage con\r\n\r\n  git add foo.txt\r\n\r\nAll'esecuzione di \"git add foo.txt\" lo stage aggiunge al blob storage il un nuovo blob col nuovo contenuto di \"foo.txt\" e, contestualmente, aggiorna il tree \"libs\" perché il file \"foo.txt\" punti al suo nuovo contenuto\r\n\r\n\r\n\r\n     [ stage ]  \r\n       |    |\r\n       |     \\\r\n       |      └── tree object  \"libs\" \r\n       |          contains \"foo.txt\"\r\n       |                        |\r\n       |                        └────────────────────────────────────────\r\n       |                                                                 \\\r\n       └──── tree oject (name=templates)                                  blob object (nuovo contenuto di foo.txt)\r\n                        (contains: bar.txt)                                   \r\n                                  |                           \r\n                                  └────────────────────────────────────── blob object (contenuto iniziale dei file)\r\n\r\n\r\nProseguiamo a modificare il file system aggiungendo un nuovo file \"doh.html\"\r\n\r\n\r\n  git add doh.html\r\n\r\nCome prima: git aggiunge un nuovo blob object col contenuto del file e, contestualmente, aggiunge nel tree \"libs\" un nuovo puntatore chiamato \"doh.html\" che punta al nuovo blob object\r\n\r\n\r\n\r\n\r\n     [ stage ]  \r\n       |    |                                      ────────────────────── blob object (contenuto di doh.html)\r\n       |     \\                                   /\r\n       |      └── tree object  \"libs\"           /\r\n       |          contains \"foo.txt\"  +  contains \"doh.html\" \r\n       |                        |\r\n       |                        └────────────────────────────────────────\r\n       |                                                                 \\\r\n       └──── tree oject (name=templates)                                  blob object (nuovo contenuto di foo.txt)\r\n                        (contains: bar.txt)                                   \r\n                                  |                           \r\n                                  └────────────────────────────────────── blob object (contenuto iniziale dei file)\r\n\r\n\r\n\r\n\r\n\r\n\r\nSiamo a posto. Questa struttura rappresenta esattamente la nuova situazione sul file system.\r\nMa a noi interessa anche che git conservi la storia.\r\nPerché git possa anche conservare la situazione passata del nostro filesystem, non resta che memorizzare da qualche parte il fatto che questa nuova situazione (lo stato attuale dello stage) sia figlia della precedente situazione (il vecchio commit).\r\n\r\nIn effetti, git aggiunge automaticamente un'informazione sullo stage: un puntatore al commit dal quale si proviene\r\n\r\n  commit 1\r\n     ↑\r\n   stage\r\n\r\nLa freccia rappresenta il fatto che lo stage sia figlio del \"commit 1\". È un semplice puntatore. Nessuna sopresa, se ci pensi; tutto git, dopo tutto, utilizza il solito, medesimo, semplicissimo modello: un database chiave/valore per conservare il dato, e l'utilizzo delle chiavi come puntatori tra un elemento e l'altro.\r\n\r\n\r\nOk. Adesso committa\r\n\r\n\r\n  git commit -m \"Il mio secondo commit!\"\r\n\r\n\r\nCon l'operazione di commit si dice a git \"Ok, prendi l'attuale stage e fallo diventare il tuo nuovo commit. Poi restituiscimi lo stage così che possa fare una nuova modifica\"\r\n\r\n\r\nDopo il commita nel database di git ci ritroviamo\r\n\r\n   commit 1\r\n      ↑\r\n   commit 2\r\n      ↑\r\n    stage\r\n\r\n\r\nRicapitolando:\r\n\r\n1. git memorizza sempre i file nella loro interezza\r\n2. il \"commit\" è uno dei tanti oggetti conservati dentro il database chiave-valore di git. È un contenitore di tanti puntatori ad altri oggetti del database: i tree che rappresentano directory con nomi di file che a loro volta puntano ad altri tree (sottodirectory) o a dei blob (il contenuto dei file)\r\n3. ogni commit ha un puntatore al commit padre da cui deriva\r\n3. lo stage è uno spazio di appoggio nel quale costruiamo a colpi di \"git add\" il nuovo commit\r\n4. con \"git commit\" registriamo l'attuale stage facendolo diventare il nuovo commit.\r\n\r\n\r\n\r\nBene: adesso hai tutta la teoria per capire i concetti più astrusi di git come il rebase, il cherrypick, l'octopus-merge, il rebase interattivo, il revert e il reset.\r\nPassiamo al pratico.\r\n\r\n\r\n\r\n### I comandi di git\r\n\r\n### Obiettivo 1 : creare un repository e due commit\r\n\r\nCrea da qualche parte una directory e lancia \"git init\"\r\n\r\n  cd /tmp\r\n  mkdir progetto\r\n  cd progetto\r\n  git init\r\n\r\n \r\n\r\nLa directory \"progetto\" è diventata un repository git. Fisicamente il repository è conservato in una directory nascosta, chiamata \".git\", dentro \"progetto\"\r\n\r\n  ls -A\r\n    .git\r\n\r\nDentro \".git\" c'è lo stage, il blog storage e un sacco di altra roba. Ma non avrai mai bisogno di accederci. Sappi solo che quello *è* il repository sul quale lavorerai.\r\n\r\nCreiamo un file e committiamolo\r\n\r\n  echo inizio > file.txt           # creo il file\r\n  git add file.txt                 # aggiungo il file allo stage\r\n  git commit -m \"inizio\"           # committo lo stage\r\n\r\n\r\n|   file system    |    stage       |   repository\r\n             ---add--->         ---commit--->\r\n\r\n\r\nSul repository si crea il commit A\r\n\r\n    A\r\n\r\nProseguiamo modificando il file\r\n\r\n  echo nuova riga >> file.txt\r\n  git add file.txt\r\n  git commit -m \"cambiamento B\"\r\n\r\nSul repository si crea il commit B figlio del commit A\r\n\r\n   A--B\r\n\r\n### Obiettivo 2: tornare indietro nel tempo\r\n\r\nRicordi che in git tutto è conservato in un database chiave/valore?\r\nPuoi usare la chiave per referenziare un qualunque oggetto.\r\nAdesso proviamo a tornare indietro nel tempo, al commit A, utilizzando il comando \"checkout\".\r\n\r\n|   file system    |    stage       |   repository\r\n             ---add--->         ---commit--->\r\n             <------------checkout-----------\r\n\r\nIl comando checkout prende il commit indicato e lo copia nel filesystem e nello stage.\r\nGià: ma qual è la chiave del commit A?\r\nLo scopriamo col comando \"git log\" che mostra tutto quello che abbiamo fatto fin'ora\r\n\r\n  git log  --oneline\r\n  00c6637 cambiamento B\r\n  621f0a8 inizio\r\n\r\n\r\nOttimo! La chiave del commit A è \"621f0a8\". Uhm, un po' scomodo come sistema.\r\nComunque: torniamo indietro al passato, al momento del commit A\r\n\r\n  git checkout 621f0a8 \r\n  cat file.txt\r\n    inizio\r\n\r\neffettivamente, il file.txt è tornato allo stato del primo commit.\r\n\r\n\r\n\r\n### Obiettivo 3: creare un branch in modalità detached\r\n\r\nPotremmo rappresentare la nostra situazione attuale con\r\n\r\n  A*---B\r\n\r\nCioè: ci sono due commit, A e B. Il commit B è figlio di A. Noi al momento siamo sul commit A.\r\nChe succederebbe se adesso facessimo qualche modifica e committassimo?\r\nAccadrebbe che divergeremmo dalla linea A---B e di fatto divergeremmo.\r\nCioè, si creerebbe questa situazione\r\n\r\n  A---B\r\n   \\\r\n    C*\r\n\r\nCioè: avremmo creato un branch. Proviamo\r\n\r\n\r\n  echo foobar > altrofile.txt\r\n  git add altrofile.txt\r\n  git commit -m \"creo un branch\"\r\n  git log --graph --all --oneline\r\n\r\n   * b8b1146 creo un branch\r\n   | * 00c6637 cambiamento B\r\n   |/\r\n   * 621f0a8 inizio\r\n\r\nHai ottenuto un branch, senza il meccanismo della copia che utilizza SVN: il modello a chiave/valore e puntatori di git rende molto economico rappresentare un branch; semplicemente, basta memorizzare che i commit C e B abbiano come padre comune il commit A\r\n\r\n  A---B\r\n   \\\r\n    C\r\n\r\nDue osservazioni importanti. \r\nLa prima per ribadire il concetto chd git non ha mai memorizzato i \"diff\" tra i file. A, B e C sono snapshot dell'intero progetto. È molto importante ricordarselo, perché ti aiuterà a capire che tutte le considerazioni che sei sempre stato abituato a fare con SVN qui non valgono.\r\nLa seconda è un po' sorprendente: i rami che hai appena visto non sono \"i branch\" di git. In git i rami sono delle etichette. Te ne parlerò a brevissimo, ma abituati giù a ripeterti: in git i branch non sono rami di sviluppo.\r\n\r\n\r\n### Obiettivo 3: creare un branch\r\n\r\nCon il comando checkout hai imparato a spostarti da un commit all'altro\r\n\r\n  git log --graph --all --oneline\r\n\r\n   * b8b1146 creo un branch\r\n   | * 00c6637 cambiamento B\r\n   |/\r\n   * 621f0a8 inizio\r\n\r\n   git checkout 621f0a8\r\n   git checkout b8b1146 \r\n   git checkout 00c6637\r\n\r\nSì, però, ammettiamolo: gestire i commit A, B e C dovendoli chiamare b8b1146, 00c6637 e 621f0a8 è di una scomodità unica.\r\nPer fortuna git fornisce uno strumento molto comodo.\r\nIl modello è sempre lo stesso: un puntatore ad un elemento del database chiave/valore.\r\nImmagina di avere a disposizione una variabile, con un certo nome, nella quale conservare la chiave di un certo commit.\r\nPraticamente, avresti qualcosa di simile ad un'etichetta da applicare ad un commit per poterlo chiamare con un nome invece che con la sua chiave\r\n\r\n   * b8b1146 creo un branch\r\n   | * 00c6637 cambiamento B  <== master\r\n   |/\r\n   * 621f0a8 inizio\r\n\r\ngit aggiunge da solo 2 etichette: HEAD e master.\r\nHEAD è l'etichetta che punta al commit corrente, quello che si sta visualizzando nel proprio filesystem.\r\nL'etichetta \"master\", invece, è aggiunta automaticamente da git alla creazione del repository.\r\nIn questo momento \"master\" punta al commit 00c6637\r\n\r\nA---B master\r\n\r\n\r\nPer cui, per andare sul commit 00c6637 puoi eseguire\r\n\r\n  git checkout master\r\n\r\n\r\nOra attento: queste etichette in git si chiamano \"branch\". Ripetiti mille volte: un branch in git non è un ramo, è un'etichetta che punta ad un commit. Tanti comportamenti di git che appaiono assurdi e complicati diventano molto semplici se eviti di pensare ai branch di git come ad un equivalente dei branch di SVN.\r\n\r\n\r\n\r\n\r\n\r\n* torno ad A e cremo un branch\r\n* checkout\r\n* etichette\r\n\r\n* il merge\r\n* il cherrypick\r\n\r\n* rebase\r\n* eliminare un commit sbagliato\r\n\r\n* p2p\r\n* fetch\r\n* push\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}