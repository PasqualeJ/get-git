<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>get-git by arialdomartini</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>get-git</h1>
          <h2>Un manuale per imparare git rapidamente e senza grattacapi</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/arialdomartini/get-git/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/arialdomartini/get-git/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/arialdomartini/get-git" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="introduzione" class="anchor" href="#introduzione"><span class="octicon octicon-link"></span></a>Introduzione</h1>

<p>Questa guida è un po' differente.
Tutte le guide che ho letto su git si preoccupano di introdurti ai comandi base di git e lasciano ai capitoli più avanzati la descrizione degli internal e del modello di funzionamento.
Quello che ho notato, però, è che imparando git così, molti finiscono per valutarlo uno strumento simile a SVN provvisto di un set aggiuntivo di comandi complicati, il cui funzionamento resta sostanzialmente oscuro.
Facci caso: chiedi ai colleghi che già conoscono git se abbiano mai capito cosa sia l'index e se saprebbero spiegarti la differenza tra merge e rebase. Alcuni ti risponderanno di aver imparato git abbasanza da riuscire ad usarlo quotidianamente, ma di aver fatto molta fatica a capire cosa sia un rebase, o di non cogliere esattamente che uso fare dello stage. 
La mia impressione è che, una volta capito il modello interno (che è stupefacentemente semplice!) tutto git diventi improvvisamente lineare e coerente: non c'è davvero alcun motivo per cui il "rebase" dovrebbe essere un argomento misterioso.</p>

<p>Questa guida prova a spiegare git seguendo un percorso contrario a quello adottato di solito: partirai da una breve spiegazione degli internal, e finirai per imparare i comandi base e quelli avanzati (insieme!) in poco tempo e senza alcun grattacapo.</p>

<h1>
<a name="non-sono-parente-di-svn" class="anchor" href="#non-sono-parente-di-svn"><span class="octicon octicon-link"></span></a>Non sono parente di SVN</h1>

<p>Per chi arriva da SVN, git presenta una sola difficoltà: gli assomiglia vagamente. Ma è una somiglianza superficiale e ingannevole: sotto il cofano è totalmente differente.</p>

<p>Per questo ti suggerisco di rifuggire sempre dalla tentazione di fare dei paralleli: sarebbero solo fuorvianti. Troverai comandi come add, checkout, commit, branch che ti sembrerà di conoscere. Ecco: fai tabula rasa di quel che conosci, perché in git quei comandi significano cose molto molto differenti.</p>

<h1>
<a name="setup" class="anchor" href="#setup"><span class="octicon octicon-link"></span></a>Setup</h1>

<p>Installa git.
Poi configuralo perché ti riconosca</p>

<p>git config --global user.name "Arialdo Martini"
  git config --global user.emal <a href="mailto:arialdomartini@gmail.com">arialdomartini@gmail.com</a></p>

<p>Se vuoi, installa anche un client grafico. Io ti suggerisco SmartGit, che è gratuito per progetti OpenSource.
Sei pronto per usare git.</p>

<h1>
<a name="il-modello" class="anchor" href="#il-modello"><span class="octicon octicon-link"></span></a>Il modello</h1>

<h2>
<a name="3-differenze-principali" class="anchor" href="#3-differenze-principali"><span class="octicon octicon-link"></span></a>3 differenze principali</h2>

<ol>
<li>Non c'è un server: il repository è locale; git lavora al livello di nerdosità 4. La gran parte delle operazioni è locale e non richiede l'accesso alla rete. Anche per questo git è veloce a bestia.</li>
<li>Snapshot: git lavora sempre con l'intero codice sorgente del progetto e non singole directory o singoli file; con git non c'è differenza tra committare nella root o in una subdirectory. Non esiste il concetto di committare o fare il checkout di un file o di una directory: git lavora sempre sull'intero snapshot del progetto.</li>
<li>Blob, non diff: non memorizza diff ma l'intero file. Se in un file di 2 mega cambiassi un singolo carattere, git memorizzerebbe per intero la nuova versione del file. Questa è una differenza importante: SVN memorizza le differenze e, all'occorrenza, ricostruisce il file; git memorizza il file e, all'occorrenza, ricostruisce le differenze.</li>
</ol><h3>
<a name="livelli-di-nerdosit%C3%A0" class="anchor" href="#livelli-di-nerdosit%C3%A0"><span class="octicon octicon-link"></span></a>Livelli di nerdosità</h3>

<p>Sull'assenza di un server ho un po' mentito: come vedrai più avanti, git è un sistema peer-to-peer, e riesce ad interagire con dei server remoti.
Ma resta, sostanzialmente, un sistema locale.</p>

<p>Per capire quanto questo possa avvantaggiarti, pensa a questo: quando il codice sorgente di un progetto è ospitato su un computer remoto hai 4 modi per editare il codice</p>

<ol>
<li>lasci tutto il codice sul computer remoto e vi accedi con ssh per editare i file</li>
<li>trovi il modo di ottenere una copia locale del (singolo) file e lasci tutto il resto sul computer remoto</li>
<li>ottieni una copia locale di un intero albero del filesystem  e lasci il resto della storia dei commit sul computer remoto</li>
<li>ottenieni una copia locale dell'intero repository con tutti i suoi commit e lavori tutto in locale</li>
</ol><p>Avrai notato due cose.
La prima, che SVN e i sistemi di versionamento ai quali sei probabilmente abituato operano al livello 3.
La seconda, che i 4 sistemi sono elencati in ordine di comodità: quando il materiale è conservato sul sistema remoto, normalmente, il tuo lavoro è più macchinoso e scomodo.
git preferisce farti avere tutto a disposizione, sul tuo computer locale.
Qualunque cosa tu faccia, git chiede normalmente di ottenere una copia completa di quel che è presente sul server remoto. Ma non preoccuparti: git è più veloce a ottenere l'intera storia del progetto di quanto SVN lo sia ad ottenere un singolo checkout.</p>

<h3>
<a name="modello-di-storage" class="anchor" href="#modello-di-storage"><span class="octicon octicon-link"></span></a>Modello di storage</h3>

<p>Passiamo dalla terza differenza. 
SVN memorizza i file e la collezione delle varie patch (o diff) applicate nel tempo. 
git invece memorizza i file così come sono, nella loro interezza.</p>

<p>Se vuoi evitare tanti grattacapi con git, il miglior suggerimento che tu possa seguire è di trattarlo come un database chiave-valore. </p>

<p>Mettiamo di avere 2 file sul filesystem </p>

<pre><code>/
├──libs
|     └──foo.txt
|
├──templates
        └──bar.txt
</code></pre>

<p>e di volerli aggiungere a git.</p>

<p>git init
  git add libs/foo.txt
  git add templates/bar.txt</p>

<p>Con questi comandi, git prende il contenuto dei 2 file e li memorizza nel suo database chiave-valore, che è conservato su filesystem (nella directory nascosta .git) . Il database si chiama "blob storage"; git guarda il contenuto di ogni file git e gli associa un identificativo unico, la chiave (banalmente: è lo sha1 del file). Il  valore sarà il contenuto del file.</p>

<pre><code>git add libs/foo.txt       ===&gt; git salva nel Blob storage qualcosa come { chiave: ae6757ff, valore: contenuto di foo.txt}
git add templates/bar.txt  ===&gt; git salva nel Blob storage { chiave: bbe51002, valore: contenuto di bar.txt}
</code></pre>

<p>Ora, come vedi, il Blob storage conserva solo il contenuto dei file, non il loro nome. Per cui, se libs/foo.txt e templates/bar.txt avessero lo stesso contenuto, nel blob storage entrambi verrebbero conservati in un unico oggetto, identificato dal suo sha1: ae6757ff</p>

<pre><code>git add libs/foo.txt              ===&gt; Blob storage { chiave: ae6757ff, valore: contenuto_comune}
git add templates/bar.txt         ===&gt; Blob storage { chiave: ae6757ff, valore: contenuto_comune} 
</code></pre>

<p>Naturalmente, però, a noi il nome dei file e la loro posizione interessano eccome.
Per questo, nel blob storage, git memorizza anche vari altri oggetti, chiamati "tree" che servono proprio a memorizzare il contenuto delle varie directory e i nomi dei file.</p>

<p>Nel nostro caso, avremo 3 tree </p>

<p>/
   libs
   template</p>

<p>git memorizzerà che "libs" contiene "foo.txt", "template" contiene "bar.txt" e "/" contiene le directory "libs" e "templates".
Come ogni altro oggetto, anche i tree sono memorizzati come chiave/valore.</p>

<p>/         =&gt; contiene libs e template
   libs      =&gt; contiene foo.txt
   template  =&gt; contiene bar.txt</p>

<p>Essendo un database chiave-valore, per fare riferimento ad un elemento, git userà sempre la sua chiave.</p>

<p>Tutte queste strutture vengono raccolte dentro un contenitore, chiamato "commit".</p>

<p>Come forse avrai intuito, un "commit" è un altro oggetto chiave-valore, la cui chiave è uno SHA1, come per tutti gli altri oggetti, e il cui valore è la collezione dei puntatori ai tree contenuti, cioè l'elenco delle loro chiavi.
Non è troppo complicato, dopo tutto, no?</p>

<p>Quindi, il commit è l'attuale fotografia dello stato del filesystem.</p>

<p>Quando facciamo</p>

<pre><code>   git commit -m "il mio primo commit"
</code></pre>

<p>stiamo dicendo a git: "memorizza nel repository, cioè nella storia del progetto, il commit che ti ho preparato a colpi di add"</p>

<h3>
<a name="index-o-stage" class="anchor" href="#index-o-stage"><span class="octicon octicon-link"></span></a>Index o stage</h3>

<p>Fino ad ora ti ho parlato degli internal di git. Tra pochissimo arriviamo ai comandi. Ma prima vediamo un altro meccanismo interno: l'"index" o lo "stage". Lo stage risulta sempre misterioso a chi arrivi da SVN: vale la pena parlarne perché quando si sa come funziona il blob storage e lo stage, git passa da sembrare un tool contorto e incomprensibile ad essere un oggetto molto lineare e coerente.</p>

<p>Lo stage è una struttura che fa da cuscinetto tra il filesystem e il repository.</p>

<pre><code>filesystem   |   stage   |   repository
</code></pre>

<p>Il file system è la directory con i nostri file.
Il repository è un database su file, locale, che conserva la storia del filesystem
Lo stage è lo spazio che git mette a disposizione per creare il prossimo commit.</p>

<p>Fisicamente, lo stage assomiglia molto al repository: entrambi conservano i dati nel blob storage, usando le strutture che hai visto prima.</p>

<pre><code>filesystem   |   stage   |   repository
                    \          |
                     \__ Blob storage
</code></pre>

<p>Proviamo a fare delle modifiche ai nostri due file (magari aggiungendone un terzo) e committarle.</p>

<p>Avevamo</p>

<pre><code>/
├──libs
|     └──foo.txt
|
├──templates
        └──bar.txt
</code></pre>

<p>e nel blob storage avevamo</p>

<pre><code> [ commit 1 ]
   |    |
   |     \
   |      └── tree object  "libs" 
   |          contains "foo.txt"
   |                        |
   |                        └────────────────────────────────────────
   |                                                                 \
   └──── tree oject (name=templates)                                  \
                    (contains: bar.txt)                                \       
                              |                                         \ 
                              └────────────────────────────────────── blob object (contenuto del file)
</code></pre>

<p>A bocce ferme, lo stage contiene la situazione dalla quale partiamo, quindi il primo commit che avevamo fatto, con tutti i suoi tree object e i suoi blob.
Lo stage sta lì, in attesa di accogliere le modifiche che abbiamo fatto sul filesystem.</p>

<p>Modifichiamo "foo.txt", e aggiorniamo lo stage con</p>

<p>git add foo.txt</p>

<p>All'esecuzione di "git add foo.txt" lo stage aggiunge al blob storage il un nuovo blob col nuovo contenuto di "foo.txt" e, contestualmente, aggiorna il tree "libs" perché il file "foo.txt" punti al suo nuovo contenuto</p>

<pre><code> [ stage ]  
   |    |
   |     \
   |      └── tree object  "libs" 
   |          contains "foo.txt"
   |                        |
   |                        └────────────────────────────────────────
   |                                                                 \
   └──── tree oject (name=templates)                                  blob object (nuovo contenuto di foo.txt)
                    (contains: bar.txt)                                   
                              |                           
                              └────────────────────────────────────── blob object (contenuto iniziale dei file)
</code></pre>

<p>Proseguiamo a modificare il file system aggiungendo un nuovo file "doh.html"</p>

<p>git add doh.html</p>

<p>Come prima: git aggiunge un nuovo blob object col contenuto del file e, contestualmente, aggiunge nel tree "libs" un nuovo puntatore chiamato "doh.html" che punta al nuovo blob object</p>

<pre><code> [ stage ]  
   |    |                                      ────────────────────── blob object (contenuto di doh.html)
   |     \                                   /
   |      └── tree object  "libs"           /
   |          contains "foo.txt"  +  contains "doh.html" 
   |                        |
   |                        └────────────────────────────────────────
   |                                                                 \
   └──── tree oject (name=templates)                                  blob object (nuovo contenuto di foo.txt)
                    (contains: bar.txt)                                   
                              |                           
                              └────────────────────────────────────── blob object (contenuto iniziale dei file)
</code></pre>

<p>Siamo a posto. Questa struttura rappresenta esattamente la nuova situazione sul file system.
Ma a noi interessa anche che git conservi la storia.
Perché git possa anche conservare la situazione passata del nostro filesystem, non resta che memorizzare da qualche parte il fatto che questa nuova situazione (lo stato attuale dello stage) sia figlia della precedente situazione (il vecchio commit).</p>

<p>In effetti, git aggiunge automaticamente un'informazione sullo stage: un puntatore al commit dal quale si proviene</p>

<p>commit 1
     ↑
   stage</p>

<p>La freccia rappresenta il fatto che lo stage sia figlio del "commit 1". È un semplice puntatore. Nessuna sopresa, se ci pensi; tutto git, dopo tutto, utilizza il solito, medesimo, semplicissimo modello: un database chiave/valore per conservare il dato, e l'utilizzo delle chiavi come puntatori tra un elemento e l'altro.</p>

<p>Ok. Adesso committa</p>

<p>git commit -m "Il mio secondo commit!"</p>

<p>Con l'operazione di commit si dice a git "Ok, prendi l'attuale stage e fallo diventare il tuo nuovo commit. Poi restituiscimi lo stage così che possa fare una nuova modifica"</p>

<p>Dopo il commita nel database di git ci ritroviamo</p>

<p>commit 1
      ↑
   commit 2
      ↑
    stage</p>

<p>Ricapitolando:</p>

<ol>
<li>git memorizza sempre i file nella loro interezza</li>
<li>il "commit" è uno dei tanti oggetti conservati dentro il database chiave-valore di git. È un contenitore di tanti puntatori ad altri oggetti del database: i tree che rappresentano directory con nomi di file che a loro volta puntano ad altri tree (sottodirectory) o a dei blob (il contenuto dei file)</li>
<li>ogni commit ha un puntatore al commit padre da cui deriva</li>
<li>lo stage è uno spazio di appoggio nel quale costruiamo a colpi di "git add" il nuovo commit</li>
<li>con "git commit" registriamo l'attuale stage facendolo diventare il nuovo commit.</li>
</ol><p>Bene: adesso hai tutta la teoria per capire i concetti più astrusi di git come il rebase, il cherrypick, l'octopus-merge, il rebase interattivo, il revert e il reset.
Passiamo al pratico.</p>

<h3>
<a name="i-comandi-di-git" class="anchor" href="#i-comandi-di-git"><span class="octicon octicon-link"></span></a>I comandi di git</h3>

<h3>
<a name="obiettivo-1--creare-un-repository-e-due-commit" class="anchor" href="#obiettivo-1--creare-un-repository-e-due-commit"><span class="octicon octicon-link"></span></a>Obiettivo 1 : creare un repository e due commit</h3>

<p>Crea da qualche parte una directory e lancia "git init"</p>

<p>cd /tmp
  mkdir progetto
  cd progetto
  git init</p>

<p>La directory "progetto" è diventata un repository git. Fisicamente il repository è conservato in una directory nascosta, chiamata ".git", dentro "progetto"</p>

<p>ls -A
    .git</p>

<p>Dentro ".git" c'è lo stage, il blog storage e un sacco di altra roba. Ma non avrai mai bisogno di accederci. Sappi solo che quello <em>è</em> il repository sul quale lavorerai.</p>

<p>Creiamo un file e committiamolo</p>

<p>echo inizio &gt; file.txt           # creo il file
  git add file.txt                 # aggiungo il file allo stage
  git commit -m "inizio"           # committo lo stage</p>

<p>|   file system    |    stage       |   repository
             ---add---&gt;         ---commit---&gt;</p>

<p>Sul repository si crea il commit A</p>

<pre><code>A
</code></pre>

<p>Proseguiamo modificando il file</p>

<p>echo nuova riga &gt;&gt; file.txt
  git add file.txt
  git commit -m "cambiamento B"</p>

<p>Sul repository si crea il commit B figlio del commit A</p>

<p>A--B</p>

<h3>
<a name="obiettivo-2-tornare-indietro-nel-tempo" class="anchor" href="#obiettivo-2-tornare-indietro-nel-tempo"><span class="octicon octicon-link"></span></a>Obiettivo 2: tornare indietro nel tempo</h3>

<p>Ricordi che in git tutto è conservato in un database chiave/valore?
Puoi usare la chiave per referenziare un qualunque oggetto.
Adesso proviamo a tornare indietro nel tempo, al commit A, utilizzando il comando "checkout".</p>

<p>|   file system    |    stage       |   repository
             ---add---&gt;         ---commit---&gt;
             &lt;------------checkout-----------</p>

<p>Il comando checkout prende il commit indicato e lo copia nel filesystem e nello stage.
Già: ma qual è la chiave del commit A?
Lo scopriamo col comando "git log" che mostra tutto quello che abbiamo fatto fin'ora</p>

<p>git log  --oneline
  00c6637 cambiamento B
  621f0a8 inizio</p>

<p>Ottimo! La chiave del commit A è "621f0a8". Uhm, un po' scomodo come sistema.
Comunque: torniamo indietro al passato, al momento del commit A</p>

<p>git checkout 621f0a8 
  cat file.txt
    inizio</p>

<p>effettivamente, il file.txt è tornato allo stato del primo commit.</p>

<h3>
<a name="obiettivo-3-creare-un-branch-in-modalit%C3%A0-detached" class="anchor" href="#obiettivo-3-creare-un-branch-in-modalit%C3%A0-detached"><span class="octicon octicon-link"></span></a>Obiettivo 3: creare un branch in modalità detached</h3>

<p>Potremmo rappresentare la nostra situazione attuale con</p>

<p>A*---B</p>

<p>Cioè: ci sono due commit, A e B. Il commit B è figlio di A. Noi al momento siamo sul commit A.
Che succederebbe se adesso facessimo qualche modifica e committassimo?
Accadrebbe che divergeremmo dalla linea A---B e di fatto divergeremmo.
Cioè, si creerebbe questa situazione</p>

<p>A---B
   \
    C*</p>

<p>Cioè: avremmo creato un branch. Proviamo</p>

<p>echo foobar &gt; altrofile.txt
  git add altrofile.txt
  git commit -m "creo un branch"
  git log --graph --all --oneline</p>

<ul>
<li>b8b1146 creo un branch
| * 00c6637 cambiamento B
|/</li>
<li>621f0a8 inizio</li>
</ul><p>Hai ottenuto un branch, senza il meccanismo della copia che utilizza SVN: il modello a chiave/valore e puntatori di git rende molto economico rappresentare un branch; semplicemente, basta memorizzare che i commit C e B abbiano come padre comune il commit A</p>

<p>A---B
   \
    C</p>

<p>Due osservazioni importanti. 
La prima per ribadire il concetto chd git non ha mai memorizzato i "diff" tra i file. A, B e C sono snapshot dell'intero progetto. È molto importante ricordarselo, perché ti aiuterà a capire che tutte le considerazioni che sei sempre stato abituato a fare con SVN qui non valgono.
La seconda è un po' sorprendente: i rami che hai appena visto non sono "i branch" di git. In git i rami sono delle etichette. Te ne parlerò a brevissimo, ma abituati giù a ripeterti: in git i branch non sono rami di sviluppo.</p>

<h3>
<a name="obiettivo-3-creare-un-branch" class="anchor" href="#obiettivo-3-creare-un-branch"><span class="octicon octicon-link"></span></a>Obiettivo 3: creare un branch</h3>

<p>Con il comando checkout hai imparato a spostarti da un commit all'altro</p>

<p>git log --graph --all --oneline</p>

<ul>
<li>b8b1146 creo un branch
| * 00c6637 cambiamento B
|/</li>
<li>
<p>621f0a8 inizio</p>

<p>git checkout 621f0a8
git checkout b8b1146 
git checkout 00c6637</p>
</li>
</ul><p>Sì, però, ammettiamolo: gestire i commit A, B e C dovendoli chiamare b8b1146, 00c6637 e 621f0a8 è di una scomodità unica.
Per fortuna git fornisce uno strumento molto comodo.
Il modello è sempre lo stesso: un puntatore ad un elemento del database chiave/valore.
Immagina di avere a disposizione una variabile, con un certo nome, nella quale conservare la chiave di un certo commit.
Praticamente, avresti qualcosa di simile ad un'etichetta da applicare ad un commit per poterlo chiamare con un nome invece che con la sua chiave</p>

<ul>
<li>b8b1146 creo un branch
| * 00c6637 cambiamento B  &lt;== master
|/</li>
<li>621f0a8 inizio</li>
</ul><p>git aggiunge da solo 2 etichette: HEAD e master.
HEAD è l'etichetta che punta al commit corrente, quello che si sta visualizzando nel proprio filesystem.
L'etichetta "master", invece, è aggiunta automaticamente da git alla creazione del repository.
In questo momento "master" punta al commit 00c6637</p>

<p>A---B master</p>

<p>Per cui, per andare sul commit 00c6637 puoi eseguire</p>

<p>git checkout master</p>

<p>Ora attento: queste etichette in git si chiamano "branch". Ripetiti mille volte: un branch in git non è un ramo, è un'etichetta che punta ad un commit. Tanti comportamenti di git che appaiono assurdi e complicati diventano molto semplici se eviti di pensare ai branch di git come ad un equivalente dei branch di SVN.</p>

<ul>
<li>torno ad A e cremo un branch</li>
<li>checkout</li>
<li><p>etichette</p></li>
<li><p>il merge</p></li>
<li><p>il cherrypick</p></li>
<li><p>rebase</p></li>
<li><p>eliminare un commit sbagliato</p></li>
<li><p>p2p</p></li>
<li><p>fetch</p></li>
<li><p>push</p></li>
</ul>
        </section>

        <footer>
          get-git is maintained by <a href="https://github.com/arialdomartini">arialdomartini</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>